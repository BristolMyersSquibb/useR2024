---
title: "No-Code Data Analysis and Dashboards with {blockr}"
author: "John Coene (Opifex) and David Granjon (cynkra GmbH)"
format: 
  revealjs:
    footer: "Footer text"
    css: [
      "assets/style/bootstrap.min.css",
      "assets/style/extra.css"
    ]
    view-distance: 5
    mermaid:
      theme: default
    height: 900
    width: 1600
    code-link: true
    code-copy: true
    fontsize: 24pt
    navigation-mode: vertical
    controls-layout: bottom-right
    controls-tutorial: true
    chalkboard: true
    transition: slide
    background-transition: fade
    title-slide-attributes:
        data-state: "hide-menubar"
    simplemenu:
        barhtml:
            header: "<div class='menubar'><ul class='menu'></ul><div>"
            #footer: "<img src='...' class='slide-logo r-stretch'>"
        scale: 0.67
revealjs-plugins:
  - simplemenu
  - attribution
filters:
  - quarto-ext/shinylive
editor:
    render-on-save: true
---

```{r setup}
library(shinylive)
library(bslib)
library(palmerpenguins)
library(ggplot2)
library(dplyr)
```

# ![shiny logo](assets/img/shiny.svg){.center width=25%} {data-stack-name="Intro"}

> __Easy__ web apps for data science without the compromises

## ~~Easy~~ Not so easy web apps for data science without the compromises {.center style="font-size: 1.5em"}


## A cooking approach to data science ðŸ²

::::{.columns}

:::{.column}
![ ](assets/img/undraw_diet_ghvw.svg){width="50%"}
:::

:::{.column}
### Imagine if we could build an interactive datapipeline like we would prepare a meal ðŸ˜³
:::

::::

## Develop enterprise-grade dashboards isn't easy

::::{.columns}

:::{.column}
![](assets/img/undraw_cooking_p7m1.svg){width=50%}
:::

:::{.column}
- Do you know how to prepare a meal without the right recipe?
- Do you have the right ingredients?
:::

::::


## ðŸ’¡ Introducing {blockr}

::::{.columns}

:::{.column}
![](assets/img/undraw_empty_cart_co35.svg){width=50%}
:::

:::{.column}
- __No-Code__ Dashboard builder for R.
- "Shiny's WordPress".
- __Supermarket__ for data analysis with R.
:::

::::

## blockr vs Shiny

::::{.columns}

:::{.column}
```{r}
# shiny code
```
:::

:::{.column}
```{r}
# blockr code
```
:::

::::


## {blockr}'s mission statement

::::{.columns}

:::{.column}
![](assets/img/undraw_super_woman_dv-0-y.svg){width=50%}
:::

:::{.column}
- Reduce back and forth between Shiny developers and data scientist.
- Cut down development time from __weeks__ to __days__.
- Extendable.
- Reproducible code.
:::

::::

# bockr 101 {data-stack-name="blockr 101"}

## Cooking vs data science

::::{.columns}

:::{.column}
Prepare a "Puree"

1kg ðŸ¥” + 20cl ðŸ¥› + 30g ðŸ§ˆ + 1 spoon ðŸ§‚ -> ðŸ²
:::

:::{.column}
Plot me a histogram showing `flipper length` by `species` only for `female` penguins in 2009.


```{r, echo = TRUE}
penguins |>
  filter(sex == "female", year == 2009) |>
  ggplot(aes(x = flipper_length_mm)) +
  geom_histogram(aes(fill = species), alpha = 0.5, position = "identity") +
  scale_fill_manual(values = c("darkorange","darkorchid","cyan4"))
```
::::

::::


## How to build a `dplyr::select` block?

::::{.columns}

:::{.column width="70%"}
```{mermaid}
%%| mermaid-format: svg
flowchart TD
  sel_data_in(Data input)
  sel_data_out(Transformed data)
  subgraph sel_block[Select block]
    sel_select_col[Select column]
    sel_expr[Expression]
    sel_res[Result]
    sel_select_col --> sel_expr --> sel_res
  end
  sel_data_in --> sel_block --> sel_data_out
```
:::

:::{.column width="30%"}
```{r, echo=TRUE, eval=FALSE}
data |> select(<COLNAME>)
```

1 field `<COLNAME>`
:::

::::

## How to build a `dplyr::filter` block?

::::{.columns}

:::{.column width="70%"}
```{mermaid}
%%| mermaid-format: svg
flowchart TD
  filt_data_in[Data input]
  filt_data_out[Transformed data]
  subgraph filt_block[Filter block]
    filt_select_col[Select columns]
    filt_filter_func[Filter function ==, !=]
    filt_filter_val[Filter values]
    filt_expr[Expression]
    filt_res[Result]

    filt_select_col --> filt_expr
    filt_select_col --> |depends| filt_filter_val
    filt_filter_val --> filt_expr
    filt_filter_func --> filt_expr

    filt_expr --> filt_res
  end
  filt_data_in --> filt_block --> filt_data_out
```
:::

:::{.column width="30%"}
```{r, echo=TRUE, eval=FALSE}
data |> filter(<COLNAME> <FILTER_FUNC> <FILTER_VALUE>, ...)

# data |> filter(col1 == "test")
```

3 __fields__:

- `<COLNAME>`
- `<FILTER_FUNC>`
- `<FILTER_VALUE>`: depends on `<COLNAME>`
:::

::::

## Blocks and fields: ingredients and recipe step ðŸ¥¦ ðŸ¥š

::::{.columns}

:::{.column}
```{mermaid}
%%| mermaid-format: svg
flowchart TD
  blk_data_in(Data input)
  blk_data_out[Output]
  subgraph blk_block[Block]
    subgraph blk_field1[Field 1]
      value(Value)
      title(Title)
      descr(Description)
      status(Status)
    end
    blk_field2(Field 2)
    blk_field1 --> blk_expr
    blk_field2 --> blk_expr
    blk_expr(Expression)
    blk_res(result)
    blk_expr --> blk_res
  end
  blk_data_in --> blk_block --> blk_data_out
```
:::

:::{.column}
A __block__ contains:

- __fields__, build the block expression and translated into Shiny inputs.
- An __expression__, evaluated with input data: `data |> select(<COLNAMES>)`.
- (Optional) input data.
- A __result__, of the evaluated expression.
- A __class__ for customization (see advanced part).
:::

::::

## The stack: data analysis recipe ðŸ“œ

::::{.columns}

:::{.column}
```{mermaid}
%%| mermaid-format: svg
flowchart TD
  subgraph stack1[Stack]
    direction TB
    input(Data block: dataset, browser, ...);
    transform(Transform block: filter, select ...);
    output(Result: plot block);
    input --> transform --> output;
  end
```
:::

:::{.column}
Collection of instructions (blocks) to go from __data import__ to __wrangling__ (and optionally visualisation)
:::

::::

## The workspace: the dinner party ðŸŽ‰

::::{.columns}

:::{.column width=70%}
```{mermaid}
%%| mermaid-format: svg
flowchart LR
  subgraph stack2[Stack 1]
    direction TB
    input_2(Data);
    transform_2(Transform);
    output_2(Result);
    input_2 --> transform_2 --> output_2;
  end
  stack2 --> stack3
  subgraph stack3[Stack 2]
    direction TB
    input_3(Data);
    transform_3(Transform);
    output_3(Visualize);
    input_3 --> transform_3 --> output_3;
  end
```
:::

:::{.column width=30%}
Collection of recipes (stacks) to build a dashboard
:::

::::

## blockr demo

```{shinylive-r}
#| standalone: true
#| components: [viewer]
#| viewerHeight: 800
## file: app.R
webr::install("blockr", repos = "https://blockr-org.github.io/webr-repos")
webr::install("blockr.data", repos = "https://blockr-org.github.io/webr-repos")

library(blockr)

stack <- new_stack(
  block_1 = new_dataset_block(selected = "penguins", package = "palmerpenguins"),
  block_2 = new_ggplot_block("x1", "y1"),
  block_3 = new_geompoint_block("red")
)
serve_stack(stack)
```

# The registry: the blocks supermarket {data-stack-name="Registry"}

## Registry 101

# Create your own blocks: the blocks supermarket {data-stack-name="Extend"}

## Create new blocks


# We need you! {data-stack-name="Conclusion"}

## Use blocks and build dashboard

Share dashboard with your teams to speed up data analysis

## Create new blocks to help your data scientists

You're an advanced R developer, you can extend blockr!
